\documentclass[12pt,a4paper]{article}
\usepackage[margin=2cm]{geometry}
\usepackage{longtable}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{caption}

%-------------------------------------------------------------------------------
% Document information
%-------------------------------------------------------------------------------
% Use standard hyphen and new line separator.  The optional line break must
% be provided outside of math mode to avoid font warnings.
\title{Pipeline Documentation for the MScProject\\[0.5em]
\large A structured description of the route-matching pipeline}
\author{\textbf{Author:} MScProject Team}
\date{\today}

\begin{document}

\maketitle

\section*{Scope and purpose}
This document describes the end-to-end data processing pipeline contained in \texttt{pipeline}
directory.  The primary goal of the pipeline is to take a
GPS\footnote{GPS: Global Positioning System.} track (stored in the GPX file
format) and produce a matched representation of that track on an
OpenStreetMap road network.  The result is an ordered sequence of matched
points and metadata that can be visualised and further analysed.  The
documentation follows established guidelines for software user documentation as
described in ISO/IEC/IEEE~26514 (``Systems and software engineering--requirements
for designers and developers of user documentation''). The pipeline is a component
of the greater system, and will be eventually ported to a web application backend. This
port will use the same code, but some changes will need to be made, such as containerizing
more of the pipeline, and creating endpoints that interact with different pipeline stages.
While the current iteration of the pipeline does not support multiple files, this will be added as a feature.

\section{Overview of the pipeline}
The pipeline is orchestrated by the Bash script \texttt{run\_pipeline.sh}, which
reads settings from a YAML configuration file and launches the various
components.  The steps outlined below summarise the high-level flow; see
Figure~\ref{fig:flowchart} for a visual depiction.  Each step logs its
progress to the console, and the resulting artefacts are stored in the
\texttt{data/} directory.

\begin{enumerate}
	\item \textbf{Configuration loading}---The script reads \texttt{settings.yml}
	      to determine the input GPX file, the desired output file names and
	      operational parameters (e.g., chunk size and search radius).
	\item \textbf{Environment setup}---A Python virtual environment is created (if
	      it does not already exist) and dependencies from
	      \texttt{requirements.txt} are installed.  This isolates the pipeline from
	      the system environment and ensures reproducibility.
	\item \textbf{Data extraction and map download}---The shell script
	      invokes\footnote{The call is performed using Python's
		      \texttt{subprocess} module within \texttt{run\_pipeline.sh}; for brevity
		      the exact command is not reproduced here. See Appendix (Code Section) for the full shell script}
	      the Python module \texttt{prepare\_map.py}.  This module parses the GPX file,
	      calculates a bounding box around the track and downloads the
	      corresponding OpenStreetMap data from the Overpass API
	      \cite{overpass}.  It then converts the sequence of track points into
	      multiple \texttt{.json} files, in GeoJSON format. Each file is defined as a "chunk", and
	      the size of each chunk can be defined in \texttt{settings.yml}. The GPX points are split into multiple files to avoid
	      exceeding URL length limits when communicating with the OSRM server, since the engine only
	      supports \textbf{GET} requests, and not \textbf{POST} with a JSON body.
	\item \textbf{Conversion of OpenStreetMap data to Protocolbuffer Binary Format (.pbf)}---\\Within a Docker
	      container, the \texttt{osmium} tool converts the downloaded
	      \texttt{.osm} file into the more compact \texttt{.pbf} format.  If
	      multiple \texttt{.osm} files exist, they are merged.  The resulting
	      \texttt{map.pbf} is stored in the volume \texttt{data/osrm\_map/}.
	\item \textbf{Graph preparation}---A second docker container runs the
	      OSRM\footnote{OSRM: Open Source Routing Machine.} backend.  It
	      performs preprocessing actions on the \texttt{.pbf} map to build the necessary routing
	      graph, using the cycling profile in \texttt{docker/osrm/profile.lua}.
	      This produces a collection of \texttt{.osrm} files that support fast, accurate
	      map matching.
	\item \textbf{Route matching}---The script then calls the Python module
	      \texttt{batch\_route\_calc.py}, which performs threaded requests to the
	      OSRM \texttt{/match} API.  Each JSON chunk is submitted to the server
	      with an adaptive search radius that grows as route heading variability increases. This is because
	      turning off a twistier road would need a larger window of observation to verify that a turn
	      is occuring because of a road change and not just inherent twistiness. The results are saved as \texttt{result\_*.json} files.
	      Any chunks that were not able to be processed for any reason are saved as empty JSON files in a separate directory. Later
	      these files will be filled with the /route\footnote{The \texttt{/route} endpoint calculates the path between two coordinates
		      based on critiera such as distance or duration} endpoint, as a fallback.
	\item \textbf{Merging and visualisation}---Once all chunks have been matched,
	      \texttt{merge\_routes.py} recursively combines the individual
	      matchings into a single route. Each recursion iteration is multi-threaded to improve performance.  The merged result is stored as
	      \texttt{merge.json}.
	\item \textbf{Visualisation}---A verification step, \texttt{plot\_merged.py} takes the resulting JSON file, and visualises it using \texttt{folium}.
	      The module creates an interactive HTML map illustrating the matched route and
	      (optionally) the raw points.  This map can be opened in a web browser. Visualisation is to make sure that the script successfully maps
	      the route and doesn't have any issues.
	\item \textbf{Clean-up}---Temporary files (intermediate JSON chunks, result
	      files, Docker volumes) and the virtual environment are deleted.  The
	      script stops and removes the OSRM containers and resets the working
	      directory to a clean state.
\end{enumerate}

\section{Component summary}
The pipeline comprises several scripts and modules.  Table~\ref{tab:modules}
summarises their roles and highlights their main functions.

\begin{longtable}{@{}p{3cm}p{8cm}p{4cm}@{}}
	\caption{Summary of key modules in the pipeline.  The descriptions focus on
		the primary purpose of each module and list notable functions exposed for
	reuse.\label{tab:modules}}                                                                                                                                                  \\
	\toprule
	\textbf{Module/file}                                                     & \textbf{Purpose}                                            & \textbf{Notable functions/scripts} \\
	\midrule
	\endfirsthead
	\multicolumn{3}{c}%
	{{\bfseries Table~\thetable\ continued from previous page}}                                                                                                                 \\
	\toprule
	\textbf{Module/file}                                                     & \textbf{Purpose}                                            & \textbf{Notable functions/scripts} \\
	\midrule
	\endhead
	\midrule \multicolumn{3}{r}{\emph{Continued on next page}}                                                                                                                  \\
	\endfoot
	\bottomrule
	\endlastfoot
	\texttt{run\_pipeline.sh}                                                & Orchestrates the entire pipeline, loading
	configuration values from \texttt{settings.yml}, creating a virtual
	environment, invoking the Python scripts, running Docker containers for
	\texttt{osmium} and OSRM, and performing clean-up.                       & Shell script; calls
	\texttt{python3 source/prepare\_map.py}, \texttt{python3
		source/batch\_route\_calc.py}, \texttt{python3 source/merge\_routes.py} and
	\texttt{python3 source/plot\_merged.py}.                                                                                                                                    \\
	\texttt{prepare\_map.py}                                                 & Parses the GPX file, extracts track points,
	calculates a bounding box and downloads the corresponding OpenStreetMap extract
	from the Overpass API.  Converts the track points into OSRM JSON files,
	supporting optional chunking.                                            & \texttt{parse\_args()},
	\texttt{main()}; uses \texttt{utils.gpx\_utils} and
	\texttt{utils.osrm\_utils}.                                                                                                                                                 \\
	\texttt{batch\_route\_calc.py}                                           & Reads the OSRM JSON chunks and performs
	parallel map matching requests to a local OSRM server.  Utilises a dynamic
	radius algorithm to adapt to heading changes, writes the matching results to
	\texttt{result\_*.json} and handles failures gracefully.                 &
	\texttt{get\_osrm\_match()}, \texttt{format\_list()}, \texttt{main()}                                                                                                       \\
	\texttt{merge\_routes.py}                                                & Merges multiple matched segments into a single
	route using a recursive "tree merge" algorithm.  Combines distances,
	durations and geometries while maintaining order.                        &
	\texttt{merge\_two()}, \texttt{tree\_merge\_routes()}, \texttt{main()}                                                                                                      \\
	\texttt{plot\_merged.py}                                                 & Generates an interactive map (HTML) of the
	merged route using Folium.  Alternates colours for different segments and
	optionally overlays raw points for comparison.                           & \texttt{main()}; uses
	\texttt{folium}, \texttt{itertools.cycle}                                                                                                                                   \\
	\texttt{utils/gpx\_utils.py}                                             & Provides helper functions for reading GPX files,
	computing bounding boxes, downloading OSM extracts and serialising data to
	JSON.                                                                    & \texttt{load\_gpx()}, \texttt{bounding\_box\_from\_data()},
	\texttt{download\_osm\_file()}, \texttt{extract\_data\_from\_gpx()}                                                                                                         \\
	\texttt{utils/osrm\_utils.py}                                            & Defines functions to convert GPX points into
	OSRM JSON payloads, calculate adaptive radii based on heading changes and
	remove spurious segments.  Also includes helpers for reading OSM bounds. &
	\texttt{points\_to\_osrm\_json()}, \texttt{compute\_dynamic\_radius()},
	\texttt{prune\_spurs()}                                                                                                                                                     \\
	\texttt{docker/docker-compose.yml}                                       & Describes the Docker services used for
	conversion and map matching.  Defines an \texttt{osmium} service for
	converting \texttt{.osm} files to \texttt{.pbf}, an \texttt{osrm-prep}
	service for building the routing graph and an \texttt{osrm-server} service
	that exposes the \texttt{/match} endpoint on port~5000.                  & YAML file; run
	with \texttt{docker compose}                                                                                                                                                \\
	\bottomrule
\end{longtable}

\section{Configuration options}
The pipeline reads configuration values from \texttt{settings.yml}.  Table~\ref{tab:settings}
summarises the available keys and their meanings.  Ensure that file paths
refer to existing locations and that chunk sizes remain within reasonable
limits to avoid exceeding URL length limits when calling the OSRM API.

\begin{longtable}{@{}p{4cm}p{9cm}@{}}
	\caption{Summary of configuration keys in \texttt{settings.yml}.\label{tab:settings}}          \\
	\toprule
	\textbf{Key}                     & \textbf{Description}                                        \\
	\midrule
	\endfirsthead
	\multicolumn{2}{c}%
	{{\bfseries Table~\thetable\ continued from previous page}}                                    \\
	\toprule
	\textbf{Key}                     & \textbf{Description}                                        \\
	\midrule
	\endhead
	\midrule \multicolumn{2}{r}{\emph{Continued on next page}}                                     \\
	\endfoot
	\bottomrule
	\endlastfoot
	\texttt{gpx\_file}               & Path to the GPX file containing the raw GPS track.  The
	file must be in standard GPX format with valid latitude, longitude and optional
	timestamp values.  Example: \texttt{data/input/test.gpx}.                                      \\
	\texttt{osm\_output}             & Path where the downloaded OpenStreetMap extract is
	stored.  The file extension should be \texttt{.osm}.  Example:
	\texttt{data/osm\_files/map.osm}.                                                              \\
	\texttt{json\_directory}         & Directory in which temporary OSRM JSON chunks are
	written.  This directory will be created if it does not exist and will be
	deleted during clean-up.  Example: \texttt{data/temp}.                                         \\
	\texttt{chunk\_size}             & Maximum number of points per OSRM JSON file.  A value
	of 0 disables chunking.  Large values may exceed the URL length limit of the
	OSRM API; the script enforces a maximum of 200.  Example: \texttt{100}.                        \\
	\texttt{radius}                  & Initial search radius (in metres) used when matching points
	to the road network.  The dynamic radius algorithm may adjust this value on a
	per-point basis.  Example: \texttt{5}.                                                         \\
	\texttt{dynamic\_radius\_window} & Size of the sliding window used when
	computing dynamic radii.  Larger values smooth the radius changes over more
	points; smaller values react more quickly to heading changes.  Example:
	\texttt{10}.                                                                                   \\
\end{longtable}

\section{Running the pipeline}
This section provides a step-by-step procedure for executing the pipeline.  It
assumes that Docker and Python 3.10 or higher are installed on the host
system.

\begin{enumerate}
	\item \textbf{Clone the repository} if you have not already done so.  In
	      a terminal, run:\\
	      % escape ampersands for LaTeX alignment
	      \texttt{git clone <repository\_url> \&\& cd MScProject/code/pipeline}
	\item \textbf{Inspect and edit \texttt{settings.yml}} to point to your GPX
	      file and adjust parameters as needed.  Do not exceed a chunk size of
	      200 points.  If necessary, increase the search radius for sparse
	      tracks.
	\item \textbf{Execute the pipeline} by running the shell script:
	      \begin{quote}
		      \texttt{bash run\_pipeline.sh}
	      \end{quote}
	      The script will create a Python virtual environment, install
	      dependencies, download the map, build the OSRM graph and perform route
	      matching.  Progress messages are printed to the console.
	\item \textbf{Monitor Docker containers}.  While the OSRM services are
	      running, you can check their status with \texttt{docker ps} and inspect
	      logs with \texttt{docker compose logs}.  The OSRM server listens on
	      \texttt{localhost:5000} and provides a health check endpoint at
	      \texttt{/health}.  If the matching step fails, ensure that the server
	      is healthy and that ports are not blocked by a firewall.
	\item \textbf{View the results}.  After the script completes, open
	      \texttt{interactive\_map\_merged.html} in a web browser.  The file is
	      located in the \texttt{data/} directory.  You can also inspect
	      \texttt{merge.json} for a structured representation of the matched
	      route.
	\item \textbf{Clean up}.  The script performs clean-up automatically.
	      Temporary files are removed and containers are shut down.  If you wish
	      to rerun the pipeline, ensure that the working directory is clean
	      and that the virtual environment has been removed.
\end{enumerate}

\section{Error handling and warnings}
Several safeguards are built into the pipeline:
\begin{itemize}
	\item If \texttt{settings.yml} is missing or lacks required keys, the script
	      exits immediately with an error message.
	\item The chunk size is validated to ensure it does not exceed 200 points.
	      Exceeding this limit may produce URLs that are too long for the OSRM
	      server to process; a fatal error is raised if the limit is broken.
	\item Requests to the OSRM server are wrapped in exception handling.  If a
	      request fails (e.g., network error), an empty result is produced and
	      saved to a \texttt{gap/} directory for later gap filling.
	\item During merging, the script checks for missing geometries or mismatched
	      code values and reports errors if encountered.  Merging proceeds even
	      when some segments cannot be combined.
	\item If the Folium plotting script cannot find any match result files, it
	      raises an explicit \texttt{FileNotFoundError}.
\end{itemize}

\section{Suggested figures and photographs}
Figures enhance understanding of the pipeline.  The following photographs or
screenshots can be inserted once you run the program.  Save each image as a
\texttt{.png} file in the \texttt{figures/} directory and reference it using
\verb|\includegraphics| in your LaTeX document.
\begin{itemize}
	\item \textbf{Pipeline flowchart}---A block diagram showing the eight steps
	      described in Section~2.  Include the creation of the virtual
	      environment, map download, OSRM preparation, matching and merging.
	      Place this diagram here as Figure~\ref{fig:flowchart} and caption it
	      ``Overview of the route-matching pipeline.''
	\item \textbf{Bounding box illustration}---A map snippet or screenshot from
	      OpenStreetMap showing the bounding box used for extracting the map
	      data.  Highlight the GPS points within the box.
	\item \textbf{OSRM server status}---A screenshot of the terminal or browser
	      showing the OSRM health endpoint returning a \texttt{200 OK} status.  This
	      confirms that the server is running correctly.
	\item \textbf{Sample matched route}---A screenshot of the interactive map
	      generated by \texttt{plot\_merged.py}, displaying both the merged
	      route and the raw GPS points.  Use different colours to distinguish
	      matched segments.
	\item \textbf{Dynamic radius plot}---If you instrument the code to record
	      dynamic radii, plot a simple chart showing how the radius varies along
	      a track segment.  This helps readers understand the purpose of the
	      adaptive radius algorithm.
\end{itemize}

\section*{References}
\begin{thebibliography}{9}
	\bibitem{overpass} Overpass API, \emph{OpenStreetMap data extractor},
	\url{https://overpass-api.de} (accessed August~2025).
	\bibitem{iso26514} ISO/IEC/IEEE~26514:2008, \emph{Systems and software
		engineering--Requirements for designers and developers of user documentation}.
\end{thebibliography}

\end{document}
