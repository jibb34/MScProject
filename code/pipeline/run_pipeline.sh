#!/bin/bash

#CONFIG SETTINGS
VENV_DIR=".venv"
REQ_FILE="requirements.txt"
MAIN_SCRIPT="prepare_map.py"
CONFIG_FILE="settings.yml"
PROFILE_PATH="osrm/profile.lua"
OSRM_DATA_DIR="osrm/data"
DEBUG=0

#YAML PARSING (generated by AI because Regex sucks):
function parse_yaml_value() {
  grep "^$1" "$CONFIG_FILE" | sed "s/^$1:[ ]*//" | tr -d '"'
}

if [ ! -f "$CONFIG_FILE" ]; then
  echo "[ERROR] $CONFIG_FILE not found!"
  exit 1
fi

#NOTE: Define setting names and values here
GPX_FILE=$(parse_yaml_value "gpx_file")
OSM_OUTPUT=$(parse_yaml_value "osm_output")
CHUNK_SIZE=$(parse_yaml_value "chunk_size")
JSON_DIR=$(parse_yaml_value "json_directory")
RADIUS=$(parse_yaml_value "radius")
DYNAMIC_WINDOW=$(parse_yaml_value "dynamic_radius_window")

OSRM_BASENAME=$(basename "$OSM_OUTPUT" .osm)

if [ -z "$GPX_FILE" ] || [ -z "$OSM_OUTPUT" ]; then
  "[ERROR] gpx_file and osm_output must be set in $CONFIG_FILE"
  exit 1
fi

if [ -z "$CHUNK_SIZE" ]; then
  CHUNK_SIZE=0
fi
if [ "$CHUNK_SIZE" -gt 200 ]; then
  echo "[ERROR] Chunk Size cannot go beyond 50 points, due to current GET limits"
  exit 1
fi

for arg in "$@"; do
  if [ "$arg" == "--debug" ]; then
    DEBUG=1
  fi
done

echo "Starting pipeline..."
echo "[INIT] GPX file: $GPX_FILE"
echo "[INIT] OSM output file: $OSM_OUTPUT"

if [ ! -d "$VENV_DIR" ]; then
  echo "[INIT] Creating virtual environment..."
  python3 -m venv "$VENV_DIR"
fi

source "$VENV_DIR/bin/activate"

echo "[INIT] Installing Python dependencies..."
pip install --quiet -r "$REQ_FILE"

echo "[PYTHON] Running Python Map Populator..."
if [ "$DEBUG" -eq 1 ]; then
  python3 "$MAIN_SCRIPT" "$GPX_FILE" "$OSM_OUTPUT" "$JSON_DIR" "$RADIUS" "$CHUNK_SIZE" --debug
else
  python3 "$MAIN_SCRIPT" "$GPX_FILE" "$OSM_OUTPUT" "$JSON_DIR" "$RADIUS" "$CHUNK_SIZE"
fi
echo "[PYTHON] Map Downloaded as .osm"

#DOCKER PREPROCESSING:
echo "[DOCKER] Copying files to Docker Volumes"
mkdir -p "$OSRM_DATA_DIR"
cp "$OSM_OUTPUT" "$OSRM_DATA_DIR/$OSRM_BASENAME.osm"

# DOCKER Conversion to .pbf
echo "[DOCKER] Starting Osmium Docker container"
docker build -t osmium-converter ./osmium

echo "[DOCKER] Performing conversion of OSM XML to PBF with Osmium"
docker run --rm \
  -v "$PWD/$OSRM_DATA_DIR:/data" \
  osmium-converter \
  cat "/data/$OSRM_BASENAME.osm" -o "/data/$OSRM_BASENAME.osm.pbf" -f pbf --overwrite >>/dev/null 2>&1

docker run --rm \
  -v "$PWD/$OSRM_DATA_DIR:/data" \
  osmium-converter \
  fileinfo "/data/$OSRM_BASENAME.osm.pbf"

if [ ! -f "$OSRM_DATA_DIR/$OSRM_BASENAME.osm.pbf" ]; then
  echo "[FATAL] Osmium conversion failed or output is missing"
  exit 1
fi

# PREPROCESSING for the OSRM
echo "[DOCKER] Pre-processing $OSM_OUTPUT with custom profile: $PROFILE_PATH"
# Extract profile and osm, set partition, Run customisation, and check if .pbf is well formed
docker run --rm \
  -v "$PWD/$OSRM_DATA_DIR:/data" \
  -v "$PWD/$PROFILE_PATH:/opt/profile.lua" \
  osrm/osrm-backend \
  bash -c "\
  osrm-extract -p /opt/profile.lua '/data/$OSRM_BASENAME.osm' &&
  osrm-partition '/data/$OSRM_BASENAME.osrm' &&
  osrm-customize '/data/$OSRM_BASENAME.osrm' " >>/dev/null 2>&1

# python3 visualize.py

# Launch OSRM Docker
echo "[DOCKER] Launching OSRM Container"

# docker-compose -f "$DOCKER_COMPOSE_FILE" up -d
# TODO: Update this to Docker-Compose. For now it just spins up a docker instance to do the matching
docker run -d \
  -v "$PWD/$OSRM_DATA_DIR:/data" \
  -p 5000:5000 \
  --name osrm \
  osrm/osrm-backend \
  osrm-routed --algorithm mld --max-matching-size 500 "/data/$OSRM_BASENAME.osrm" >>/dev/null 2>&1

echo "[DOCKER] Waiting for OSRM server to initialize"
# sleep 5

# echo "Stalled for debugging. Press ENTER to continue..."
# read

python3 batch_route_calc.py "./data/temp" $DYNAMIC_WINDOW
# python3 visualize.py
python3 plot_map.py

echo "[CLEANUP] Cleaning up JSON chunks..."
rm -rf data/temp/*
rm -rf data/results/*
echo "[CLEANUP] Removing excess map data..."
rm -rf osrm/data/*

echo "[CLEANUP] Cleaning up virtual environment..."
deactivate
echo "[CLEANUP] Shutting down Docker container"
docker rm -f osrm >/dev/null 2>&1 || true
rm -rf "$VENV_DIR"

echo "Done :)"
