<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Segment Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Leaflet CSS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <!-- Chart.js for extension graphs -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

  <style>
    html, body {
      height: 100%;
      margin: 0;
    }
    #tabs {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1100;
      display: flex;
    }
    #tabs button {
      padding: 6px 10px;
      border: none;
      background: #eee;
      cursor: pointer;
    }
    #tabs button.active {
      background: #ddd;
      font-weight: bold;
    }
    .tab-content { display: none; height: 100%; }
    .tab-content.active { display: block; }
    #map { height: 100%; }

    #controls {
      position: absolute;
      top: 40px;
      left: 10px;
      z-index: 1000;
      background: white;
      padding: 8px 12px;
      border-radius: 4px;
      box-shadow: 0 1px 5px rgba(0,0,0,0.3);
    }
  </style>
</head>
<body>
<div id="tabs">
  <button data-tab="map" class="active">Map</button>
  <button data-tab="ext">Extensions</button>
</div>

<div id="controls">
  <button id="loadBtn">Load Segments</button>
      <input type="file" id="gpxFile" accept=".gpx" />
</div>
<div id="map" class="tab-content active"></div>
<canvas id="extChart" class="tab-content"></canvas>
  <div style="margin-top:8px; display:flex; gap:16px; align-items:center;">
    <label><input type="checkbox" id="debugToggle"> Debug</label>
    <div id="legend" style="font-family:system-ui, sans-serif; font-size:12px;">
      <strong>Kind colors:</strong>
      <span style="display:inline-block;width:10px;height:10px;background:#000;vertical-align:middle;"></span> 0
      <span style="display:inline-block;width:10px;height:10px;background:#808080;vertical-align:middle;margin-left:8px;"></span> 1
      <span style="display:inline-block;width:10px;height:10px;background:#f00;vertical-align:middle;margin-left:8px;"></span> 2
      <span style="display:inline-block;width:10px;height:10px;background:#00f;vertical-align:middle;margin-left:8px;"></span> 3
      <span style="display:inline-block;width:10px;height:10px;background:#ff8c00;vertical-align:middle;margin-left:8px;"></span> 4
      <span style="display:inline-block;border:1px dashed #000;width:10px;height:10px;vertical-align:middle;margin-left:8px;"></span> unknown
    </div>
  </div>


<!-- Leaflet JS -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
        // -- Debug switch via URL (?debug=1) or checkbox
    const urlDebug = new URLSearchParams(location.search).get('debug') === '1';
    let DEBUG = urlDebug;
    window.addEventListener('DOMContentLoaded', () => {
      const chk = document.getElementById('debugToggle');
      if (chk) { chk.checked = DEBUG; chk.addEventListener('change', () => DEBUG = chk.checked); }
    });

  const map = L.map('map').setView([37.5, -105], 6);

  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 18,
    attribution: '© OpenStreetMap contributors'
  }).addTo(map);

    // logOnce: avoid console spam
    const _once = new Set();
    function logOnce(key, ...args) {
      if (_once.has(key)) return;
      _once.add(key);
      console.warn(...args);
    }

    // mapping
    function colorForKind(kRaw) {
      const n = Number(kRaw);
      switch (n) {
        case 0: return '#000000';
        case 1: return '#808080';
        case 2: return '#ff0000';
        case 3: return '#0000ff';
        case 4: return '#ff8c00';
        default: return '#000000';
      }
    }

  let segmentLayer = null;
  let gpxPoints = [];
  let extChart = null;


  async function loadSegments() {
    const bounds = map.getBounds();
    const bbox = [
      bounds.getWest().toFixed(6),
      bounds.getSouth().toFixed(6),
      bounds.getEast().toFixed(6),
      bounds.getNorth().toFixed(6)
    ].join(',');

    const API_BASE = `http://${window.location.hostname}:5005`;
    const url = `${API_BASE}/segments?bbox=${bbox}`;
    console.log("Fetching:", url);

    try {
      const response = await fetch(url);
      if (!response.ok) throw new Error(`HTTP ${response.status}`);
      const data = await response.json();

      if (DEBUG) {
        console.groupCollapsed('[route-mapper] Raw response snapshot');
        console.log('Top-level keys:', Object.keys(data));
        const feats = Array.isArray(data.features) ? data.features : [];
        console.log('features.length =', feats.length);
        console.log('feature[0]?.properties =', feats[0]?.properties);
        console.log('feature[1]?.properties =', feats[1]?.properties);
        console.groupEnd();
      }

      if (segmentLayer) map.removeLayer(segmentLayer);

          // map "kind" -> stroke color
      function colorForKind(k) {
        const n = Number(k);
        switch (n) {
          case 0: return '#000000'; // black
          case 1: return '#808080'; // grey
          case 2: return '#ff0000'; // red
          case 3: return '#0000ff'; // blue
          case 4: return '#ff8c00'; // orange
          default: return '#000000'; // fallback
        }
      }

      const cleaned = validateGeoJSONFeatures(data);

      // Build a quick histogram of kind values
      const counts = {};
      const distinctKinds = new Set();
      (cleaned.features || []).forEach(f => {
        const k = f?.properties?.kind;
        const key = (k === null || k === undefined) ? 'MISSING' : String(k);
        counts[key] = (counts[key] || 0) + 1;
        distinctKinds.add(key);
      });
      if (DEBUG) {
        console.groupCollapsed('[route-mapper] kind histogram');
        console.table(counts);
        console.groupEnd();
      }

      segmentLayer = L.geoJSON(cleaned, {
        style: (feature) => {
          const k = feature?.properties?.kind;
          const valid = k !== undefined && k !== null && !Number.isNaN(Number(k));
          if (!valid && DEBUG) {
            logOnce('kind-missing-' + JSON.stringify(feature?.properties ?? {}),
              '[route-mapper] Feature missing/invalid "kind". properties=', feature?.properties);
          }
          return {
            color: colorForKind(k),
            weight: 3,
            // visually mark unknown/missing kinds
            dashArray: valid ? null : '6 4',
            opacity: 1
          };
        },
        onEachFeature: (feature, layer) => {
          const p = feature.properties || {};
          const uid = p.uid || "unknown";
          const dir = p.direction || "undirected";
          const len = p.length_m || "N/A";
          const kind = (p.kind ?? 'unknown');
          layer.bindPopup(
            `<strong>UID:</strong> ${uid}` +
            `<br><strong>Direction:</strong> ${dir}` +
            `<br><strong>Length:</strong> ${len} m` +
            `<br><strong>Kind:</strong> ${kind}`
          );
          layer.on('click', () => showSegmentGraph(feature));
          if (DEBUG) {
            layer.on('mouseover', () => console.debug('[route-mapper] hover feature props:', p));
          }
        }
      }).addTo(map);
    } catch (err) {
      alert("Failed to load segments:\n" + err.message);
      console.error(err);
    }
  }
  function validateGeoJSONFeatures(data) {
  let validFeatures = [];
  let invalidCount = 0;

  data.features.forEach((feature, idx) => {
    const coords = feature?.geometry?.coordinates;

    if (
      !coords ||
      !Array.isArray(coords) ||
      coords.length < 2 ||
      coords.some(
        (c, i) =>
          !Array.isArray(c) ||
          c.length !== 2 ||
          typeof c[0] !== 'number' ||
          typeof c[1] !== 'number' ||
          !isFinite(c[0]) ||
          !isFinite(c[1])
      )
    ) {
      console.warn(`❌ Invalid feature at index ${idx}:`, feature);
      invalidCount++;
    } else {
      validFeatures.push(feature);
    }
  });

  console.info(`✅ Valid features: ${validFeatures.length}`);
  if (invalidCount > 0) console.warn(`⚠️ Invalid features skipped: ${invalidCount}`);

  return {
    type: "FeatureCollection",
    features: validFeatures,
  };
}
function parseGPX(text) {
  const xml = new DOMParser().parseFromString(text, 'application/xml');
  const pts = Array.from(xml.getElementsByTagName('trkpt'));
  gpxPoints = pts.map(pt => {
    const lat = parseFloat(pt.getAttribute('lat'));
    const lon = parseFloat(pt.getAttribute('lon'));
    const ext = {};
    pt.querySelectorAll('extensions *').forEach(el => {
      const val = parseFloat(el.textContent);
      if (!isNaN(val)) ext[el.tagName] = val;
    });
    return { lat, lon, extensions: ext };
  });
}

document.getElementById('gpxFile').addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = () => parseGPX(reader.result);
  reader.readAsText(file);
});

function showSegmentGraph(feature) {
  if (!gpxPoints.length) {
    alert('Upload a GPX file with extension data first.');
    return;
  }
  const coords = feature.geometry?.coordinates || [];
  let minLat = 90, maxLat = -90, minLon = 180, maxLon = -180;
  coords.forEach(c => {
    const lon = c[0], lat = c[1];
    if (lat < minLat) minLat = lat;
    if (lat > maxLat) maxLat = lat;
    if (lon < minLon) minLon = lon;
    if (lon > maxLon) maxLon = lon;
  });
  const pad = 0.0005;
  minLat -= pad; maxLat += pad; minLon -= pad; maxLon += pad;

  const pts = gpxPoints.filter(p => p.lat >= minLat && p.lat <= maxLat && p.lon >= minLon && p.lon <= maxLon);
  if (!pts.length) {
    alert('No extension data for this segment.');
    return;
  }
  const labels = pts.map((_, i) => i + 1);
  const extKeys = new Set();
  pts.forEach(p => Object.keys(p.extensions || {}).forEach(k => extKeys.add(k)));
  const colors = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'cyan', 'magenta', 'black'];
  let colorIdx = 0;
  const datasets = [];
  extKeys.forEach(k => {
    const data = pts.map(p => {
      const v = p.extensions && p.extensions[k];
      return Number.isFinite(v) ? v : null;
    });
    if (data.some(v => v !== null)) {
      datasets.push({ label: k, data, borderColor: colors[colorIdx++ % colors.length], fill: false });
    }
  });
  if (!datasets.length) {
    alert('No extension data found for this segment.');
    return;
  }
  const ctx = document.getElementById('extChart').getContext('2d');
  if (extChart) extChart.destroy();
  extChart = new Chart(ctx, {
    type: 'line',
    data: { labels, datasets },
    options: {
      responsive: true,
      scales: {
        x: { title: { display: true, text: 'Point' } },
        y: { title: { display: true, text: 'Value' } }
      }
    }
  });
  activateTab('ext');
}

function activateTab(tab) {
  document.querySelectorAll('#tabs button').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.tab === tab);
  });
  document.querySelectorAll('.tab-content').forEach(el => {
    el.classList.toggle('active', (tab === 'map' && el.id === 'map') || (tab === 'ext' && el.id === 'extChart'));
  });
}

document.querySelectorAll('#tabs button').forEach(btn => {
  btn.addEventListener('click', () => activateTab(btn.dataset.tab));
});


  document.getElementById('loadBtn').addEventListener('click', loadSegments);

  if (DEBUG) console.info('[route-mapper] Debug mode ON. Use ?debug=1 to auto-enable.');
</script>

</body>
</html>

