% Auto-generated appendix of code listings moved from main text.
\clearpage
\chapter{Code Listings and File Structures}
\label{apx:extracted-code}

% from listing #1
\begin{lstlisting}[language=bash, caption={{\ttfamily Code directory for Segmentation Engine}}, label={lst:directory}]
segmentation-engine/
├─ src/ (http/, io/, core/, models/)
├─ include/        # single-header deps: httplib, nlohmann/json
├─ build/          # Build files and settings for the engine
├─ config/         # settings.json,
├─ scripts/        # build & run helpers
├─ CMakeLists.txt
└─ Dockerfile
    

\end{lstlisting}

% from listing #2
\begin{lstlisting}[caption={{\ttfamily \texttt{CMakeLists.txt} CMake file for Segmentation Engine}}, label={lst:CMakeLists}]
cmake_minimum_required(VERSION 3.10)
project(segmentation_engine)
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

add_executable(segmentation_engine
  src/main.cpp
  src/http/http_handler.cpp
  src/io/geojson_parser.cpp
  # (+ later models/ and analysis/ files)
)

target_include_directories(segmentation_engine PRIVATE include src)
target_link_libraries(segmentation_engine PRIVATE pthread)
    

\end{lstlisting}

% from listing #3
\begin{lstlisting}[caption={{\ttfamily \texttt{Dockerfile}: builds and deploys the Dockerized Segmentation Engine}}, label={lst:Dockerfile}]
FROM ubuntu:20.04
ARG DEBIAN_FRONTEND=noninteractive
ENV TZ=Etc/UTC
WORKDIR /app

RUN apt-get update && \
    apt-get install -y --no-install-recommends \
      cmake build-essential git curl && \
    rm -rf /var/lib/apt/lists/*

COPY . /app
RUN mkdir -p build && cd build && cmake .. && make -j

EXPOSE 5005
ENTRYPOINT ["/app/build/segmentation_engine"]
    

\end{lstlisting}

% from listing #4
\begin{lstlisting}[language=bash, caption={{\ttfamily \texttt{build\_and\_deploy.sh}: Runs the build process and launches the Engine}}, label={lst:buildanddeploy}]
#!/usr/bin/env bash
set -e
IMG=segmentation_engine:latest
CTR=segmentation_container
HOST_PORT=${1:-8080}
CONTAINER_PORT=${2:-8080}

docker build -t "$IMG" .
docker rm -f "$CTR" 2>/dev/null || true
docker run -d -p "$HOST_PORT:$CONTAINER_PORT" --name "$CTR" "$IMG"
echo "http://localhost:$HOST_PORT"
    

\end{lstlisting}

% from listing #5
\begin{lstlisting}[language=C++, caption={{\ttfamily \texttt{main.cpp}: Main orchestrator of engine, sets up server and defines POST endpoints}}, label={lst:maincpp}]
/* main.cpp: register routes by capturing `action` BY VALUE */
httplib::Server server;
server.set_payload_max_length(512ull * 1024ull * 1024ull); // large uploads
server.set_read_timeout(60,0); server.set_write_timeout(60,0);

HttpHandler handler;
server.Post("/segment", [action=std::string("segment"), &handler]
  (const auto& req, auto& res){ handler.callHandler(req,res,action); });
server.Post("/debug", [action=std::string("debug"), &handler]
  (const auto& req, auto& res){ handler.callHandler(req,res,action); });

server.listen("0.0.0.0", 8080);
    

\end{lstlisting}

% from listing #6
\begin{lstlisting}[language=C++, caption={{\ttfamily \texttt {http\_handler.cpp}: Checks for parsing error of JSON body}}, label={lst:jsonvalid}]
// On parse_error: compute byte->(line,col) and return a snippet with a caret.
auto [line, col] = calc_line_col(req.body, e.byte);
nlohmann::json err = {{"ok",false}, {"line",line}, {"column",col},
  {"context", context_snippet(req.body, e.byte)}};
res.status = 400; res.set_content(err.dump(2), "application/json");
    

\end{lstlisting}

% from listing #7
\begin{lstlisting}[language=C++, caption={{\ttfamily \texttt{osrm\_enriched.hpp}: In the header, defines all structs for holding route data}}, label={lst:structshpp}]
// models (subset): no OSRM steps; tolerate null tracepoints; epoch times in GPX.
struct Geometry {
  std::string type; // "LineString"
  std::vector<std::array<double,2>> coordinates; // [lon,lat]
};

struct Leg {
  nlohmann::json annotation;
  std::string summary;
  double weight=0, duration=0, distance=0;
};

struct Matching {
  double confidence=0;
  Geometry geometry;
  std::vector<Leg> legs;
  std::string weight_name;
  double weight=0, duration=0, distance=0;
};

struct GpxPoint {
  double lat=0, lon=0, ele=0;
  long long time=0; // epoch seconds
  nlohmann::json extensions; // array {key,value} OR object
};

struct Tracepoint {
  bool matched=false; // supports null entries
  int alternatives_count=0, waypoint_index=-1, matchings_index=-1;
  std::array<double,2> location{0.0,0.0};
  std::string name;
  std::vector<GpxPoint> gpx_list;
};

struct OsrmMatchResponse {
  std::string code;
  std::vector<Matching>   matchings;   // rule: use first
  std::vector<Tracepoint> tracepoints; // null-safe placeholders
};
    

\end{lstlisting}

% from listing #8
\begin{lstlisting}[language=C++, caption={{\ttfamily \texttt{osrm\_enriched.hpp} Also in header, define function overloads for from\_json(), which replaces same function in json.get()}}, label={lst:fromjson}]
// Example: robust Geometry::from_json (no throws on null/wrong types)
inline void from_json(const nlohmann::json& j, Geometry& g) {
  if (j.contains("type") && j["type"].is_string()) g.type = j["type"].get<std::string>();
  g.coordinates.clear();
  if (j.contains("coordinates") && j["coordinates"].is_array()) {
    g.coordinates.reserve(j["coordinates"].size());
    for (const auto& pt : j["coordinates"]) {
      if (pt.is_array() && pt.size()>=2 && pt[0].is_number() && pt[1].is_number())
        g.coordinates.push_back({pt[0].get<double>(), pt[1].get<double>()});
    }
  }
}

// Tracepoint: allow null entries and keep index alignment
inline void from_json(const nlohmann::json& j, Tracepoint& t) {
  if (j.is_null()) { t.matched=false; t.waypoint_index=-1; t.matchings_index=-1; t.gpx_list.clear(); return; }
  t.matched=true;
  if (j.contains("waypoint_index") && j["waypoint_index"].is_number_integer())
    t.waypoint_index = j["waypoint_index"].get<int>();
  // ... (similar guards for other fields; parse gpx_list if array)
}
    

\end{lstlisting}
